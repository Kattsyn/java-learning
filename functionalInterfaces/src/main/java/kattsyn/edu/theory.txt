package kattsyn.edu;

public class Main {
    public static void main(String[] args) {

    }

    /*
    Функциональный интерфейс - интерфейс, который содержит только один анонимный метод. Используется в лямбда-выражениях,
    делая код короче и понятней. А также в StreamAPI. Основные функциональные интерфейсы доступные в java.util.function

    Predicate<T> - Функциональный интерфейс Predicate<T> проверяет соблюдение некоторого условия.
    Если оно соблюдается, то возвращается значение true.
    В качестве параметра лямбда-выражение принимает объект типа T.

    Consumer<T> - Consumer<T> выполняет некоторое действие над объектом типа T, при этом ничего не возвращая.

    Function<T, R> - Функциональный интерфейс Function<T, R> представляет функцию перехода от объекта типа T к объекту типа R

    Supplier<T> - не принимает никаких аргументов, но должен возвращать объект типа T

    UnaryOperator<T> - принимает в качестве параметра объект типа T, выполняет над ними операции и возвращает результат операций в виде объекта типа T
    (Принимает Т, что-то делает, и возвращает объект типа Т)

    BinaryOperator<T> - принимает в качестве параметра два объекта типа T, выполняет над ними бинарную операцию
    и возвращает ее результат также в виде объекта типа T

    Consumer - потребитель, он получает на вход значение, что-то с ним делает, но ничего не возвращает.
    Predicate - утверждение, получает на вход значение и возвращает истину/ложь в зависимости от значения.
    Function - функция, думаю понятно как работает.
    Supplier - поставщик, предоставляет значения, на вход ничего не принимает.
    Operator - оператор, как функция, только принимает и возвращает значения одного типа.

    Они нужны чтобы каждый раз не писать заново интерфейсы. Чтобы использовать их в качестве параметров методов.
    Хранить лямбды в переменных, а эти функциональные интерфейсы использовать как типы и т.д.

    Функциональные интерфейсы можно инстанцировать следующими способами:
    1) Создать класс и там имплементировать. Громоздко и имеет мало смысла, если не будем переиспользовать этот класс.
    class IntSquare implements IntUnaryOperator {
        @Override
        public int applyAsInt(int operand) {
            return operand * operand
        }
    }
    2) лямбда-функцией
    IntUnaryOperator square = x -> {
        return x*x;
    }
    IntUnaryOperator square = x -> x*x; //если имеет одно выражение, то можно без блока кода обойтись

    В теле метода лямбда-выражения можно обращаться к:
    1. параметрам функции, также можно создавать внутри выражения новые переменные и использовать их
    2. к полям класса, в теле которого объявлена лямбда-функция
    3. к полям, которые объявлены внутри метода, в котором находится лямбда-выражение,
    но такие поля должны быть final, либо создаваться и присваиваться значение им ровно один раз, до использования ее в лямбда-выражении
    Обойти это можно используя массив из одного элемента
    int[] counter = new int[] {0};
    IntSupplier sequence = () -> counter[0]++;
    ведь ссылка меняться не будет при изменении этого единственного элемента

    3) Функциональный интерфейс можно инстанцировать ссылкой на метод.
    ToIntFunction<String> intParser = Integer::parseInt; - здесь ссылаемся на статичный метод (ИмяКласса::ИмяМетода)
    Consumer<Object> printer = System.out::println; - здесь ссылаемся на НЕ статичный метод (КонкретныйОбъект::ИмяМетода)
    Function<Object, String> objectToString = Object::toString; - здесь мы вызываем метод, который содержится внутри класса,
    над которым и проводим действия (ИмяКлассаНадКоторымДелаемЧто-то::МетодВнутриЭтогоКласса)

    Также можно ссылаться на конструктор
    IntFunction<String[]> arrayAllocator = String[]::new;

    У стандартных функциональных интерфейсов есть также статические методы, например
    IntPredicate isOdd = x -> x % 2 != 0;
    IntPredicate isEven = isOdd.negate(); - обратный isOdd();

    IntPredicate p1 = ..., p2 = ...;
    IntPredicate p3 = p1.and(p2); - конъюнкция

    Consumer<Object> printer = System.out::println;
    List<Object> objects = new ArrayList<>();
    Consumer<Object> collector = objects::add;

    Consumer<Object> combinedConsumer = printer.andThen(collector); //объединяем consumer'ы

    DoubleUnaryOperator square = x -> x * x;
    DoubleUnaryOperator sin = Math::sin;

    DoubleUnaryOperator complexFunction1 = sin.andThen(square); // (sin(x))^2
    DoubleUnaryOperator complexFunction2 = sin.compose(square); // sin(x^2)
     */


}
